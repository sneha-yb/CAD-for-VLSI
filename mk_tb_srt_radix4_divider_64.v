//
// Generated by Bluespec Compiler, version 2023.01-39-g42fb7b6c (build 42fb7b6c)
//
// On Sun Dec 10 10:31:09 IST 2023
//
//
// Ports:
// Name                         I/O  size props
// CLK                            I     1 clock
// RST_N                          I     1 reset
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mk_tb_srt_radix4_divider_64(CLK,
				   RST_N);
  input  CLK;
  input  RST_N;

  // register en
  reg en;
  wire en$D_IN, en$EN;

  // register rg_cnt
  reg [5 : 0] rg_cnt;
  wire [5 : 0] rg_cnt$D_IN;
  wire rg_cnt$EN;

  // register rg_cycle
  reg [31 : 0] rg_cycle;
  wire [31 : 0] rg_cycle$D_IN;
  wire rg_cycle$EN;

  // register rg_funct3
  reg [2 : 0] rg_funct3;
  wire [2 : 0] rg_funct3$D_IN;
  wire rg_funct3$EN;

  // register rg_opcode
  reg [3 : 0] rg_opcode;
  wire [3 : 0] rg_opcode$D_IN;
  wire rg_opcode$EN;

  // ports of submodule ifc_div
  reg [3 : 0] ifc_div$ma_start_opcode;
  reg [2 : 0] ifc_div$ma_start_funct3;
  wire [64 : 0] ifc_div$mav_result;
  wire [63 : 0] ifc_div$ma_start_dividend, ifc_div$ma_start_divisor;
  wire ifc_div$EN_ma_set_flush,
       ifc_div$EN_ma_start,
       ifc_div$EN_mav_result,
       ifc_div$ma_set_flush_c;

  // remaining internal signals
  wire [31 : 0] IF_rg_cycle_BIT_31_THEN_NEG_rg_cycle_ELSE_rg_c_ETC___d7,
		x__h392;

  // submodule ifc_div
  mk_srt_radix4_divider ifc_div(.CLK(CLK),
				.RST_N(RST_N),
				.ma_set_flush_c(ifc_div$ma_set_flush_c),
				.ma_start_dividend(ifc_div$ma_start_dividend),
				.ma_start_divisor(ifc_div$ma_start_divisor),
				.ma_start_funct3(ifc_div$ma_start_funct3),
				.ma_start_opcode(ifc_div$ma_start_opcode),
				.EN_ma_start(ifc_div$EN_ma_start),
				.EN_mav_result(ifc_div$EN_mav_result),
				.EN_ma_set_flush(ifc_div$EN_ma_set_flush),
				.RDY_ma_start(),
				.mav_result(ifc_div$mav_result),
				.RDY_mav_result(),
				.RDY_ma_set_flush());

  // register en
  assign en$D_IN = 1'b0 ;
  assign en$EN = 1'b0 ;

  // register rg_cnt
  assign rg_cnt$D_IN = rg_cnt + 6'd1 ;
  assign rg_cnt$EN =
	     (rg_cycle[31] ?
		-IF_rg_cycle_BIT_31_THEN_NEG_rg_cycle_ELSE_rg_c_ETC___d7 :
		IF_rg_cycle_BIT_31_THEN_NEG_rg_cycle_ELSE_rg_c_ETC___d7) ==
	     32'd0 &&
	     (rg_cnt == 6'd0 || rg_cnt == 6'd1 || rg_cnt == 6'd2 ||
	      rg_cnt == 6'd3 ||
	      rg_cnt == 6'd4 ||
	      rg_cnt == 6'd5 ||
	      rg_cnt == 6'd6 ||
	      rg_cnt == 6'd7) ;

  // register rg_cycle
  assign rg_cycle$D_IN = rg_cycle + 32'd1 ;
  assign rg_cycle$EN = 1'd1 ;

  // register rg_funct3
  assign rg_funct3$D_IN = 3'h0 ;
  assign rg_funct3$EN = 1'b0 ;

  // register rg_opcode
  assign rg_opcode$D_IN = 4'h0 ;
  assign rg_opcode$EN = 1'b0 ;

  // submodule ifc_div
  assign ifc_div$ma_set_flush_c = 1'b0 ;
  assign ifc_div$ma_start_dividend = 64'h0000000000045FEA ;
  assign ifc_div$ma_start_divisor = 64'h0000000000023BC3 ;
  always@(rg_cnt)
  begin
    case (rg_cnt)
      6'd0, 6'd4: ifc_div$ma_start_funct3 = 3'b100;
      6'd1, 6'd5: ifc_div$ma_start_funct3 = 3'b110;
      6'd2, 6'd6: ifc_div$ma_start_funct3 = 3'b101;
      6'd3: ifc_div$ma_start_funct3 = 3'b111;
      default: ifc_div$ma_start_funct3 = 3'b111;
    endcase
  end
  always@(rg_cnt)
  begin
    case (rg_cnt)
      6'd0, 6'd1, 6'd2, 6'd3: ifc_div$ma_start_opcode = 4'b1100;
      default: ifc_div$ma_start_opcode = 4'b1110;
    endcase
  end
  assign ifc_div$EN_ma_start =
	     (rg_cycle[31] ?
		-IF_rg_cycle_BIT_31_THEN_NEG_rg_cycle_ELSE_rg_c_ETC___d7 :
		IF_rg_cycle_BIT_31_THEN_NEG_rg_cycle_ELSE_rg_c_ETC___d7) ==
	     32'd0 &&
	     (rg_cnt == 6'd0 || rg_cnt == 6'd1 || rg_cnt == 6'd2 ||
	      rg_cnt == 6'd3 ||
	      rg_cnt == 6'd4 ||
	      rg_cnt == 6'd5 ||
	      rg_cnt == 6'd6 ||
	      rg_cnt == 6'd7) ;
  assign ifc_div$EN_mav_result = 1'd1 ;
  assign ifc_div$EN_ma_set_flush = 1'b0 ;

  // remaining internal signals
  assign IF_rg_cycle_BIT_31_THEN_NEG_rg_cycle_ELSE_rg_c_ETC___d7 =
	     x__h392 % 32'd38 ;
  assign x__h392 = rg_cycle[31] ? -rg_cycle : rg_cycle ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        en <= `BSV_ASSIGNMENT_DELAY 1'd1;
	rg_cnt <= `BSV_ASSIGNMENT_DELAY 6'd0;
	rg_cycle <= `BSV_ASSIGNMENT_DELAY 32'd0;
	rg_funct3 <= `BSV_ASSIGNMENT_DELAY 3'b101;
	rg_opcode <= `BSV_ASSIGNMENT_DELAY 4'b1100;
      end
    else
      begin
        if (en$EN) en <= `BSV_ASSIGNMENT_DELAY en$D_IN;
	if (rg_cnt$EN) rg_cnt <= `BSV_ASSIGNMENT_DELAY rg_cnt$D_IN;
	if (rg_cycle$EN) rg_cycle <= `BSV_ASSIGNMENT_DELAY rg_cycle$D_IN;
	if (rg_funct3$EN) rg_funct3 <= `BSV_ASSIGNMENT_DELAY rg_funct3$D_IN;
	if (rg_opcode$EN) rg_opcode <= `BSV_ASSIGNMENT_DELAY rg_opcode$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    en = 1'h0;
    rg_cnt = 6'h2A;
    rg_cycle = 32'hAAAAAAAA;
    rg_funct3 = 3'h2;
    rg_opcode = 4'hA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (ifc_div$mav_result[64] && rg_cnt == 6'd1)
	$display("after cycle %d    the 64 bit signed divsion quotient = %h  ",
		 $signed(rg_cycle),
		 ifc_div$mav_result[63:0]);
    if (RST_N != `BSV_RESET_VALUE)
      if (ifc_div$mav_result[64] && rg_cnt == 6'd2)
	$display("after cycle %d    the 64 bit signed divsion remainder = %h \n",
		 $signed(rg_cycle),
		 ifc_div$mav_result[63:0]);
    if (RST_N != `BSV_RESET_VALUE)
      if (ifc_div$mav_result[64] && rg_cnt == 6'd3)
	$display("after cycle %d    the 64 bit unsigned divsion quotient = %h",
		 $signed(rg_cycle),
		 ifc_div$mav_result[63:0]);
    if (RST_N != `BSV_RESET_VALUE)
      if (ifc_div$mav_result[64] && rg_cnt == 6'd4)
	$display("after cycle %d    the 64 bit unsigned divsion remainder = %h \n",
		 $signed(rg_cycle),
		 ifc_div$mav_result[63:0]);
    if (RST_N != `BSV_RESET_VALUE)
      if (ifc_div$mav_result[64] && rg_cnt == 6'd5)
	$display("after cycle %d    the 32 bit signed divsion quotient = %h",
		 $signed(rg_cycle),
		 ifc_div$mav_result[63:0]);
    if (RST_N != `BSV_RESET_VALUE)
      if (ifc_div$mav_result[64] && rg_cnt == 6'd6)
	$display("after cycle %d    the 32 bit signed divsion remainder = %h \n",
		 $signed(rg_cycle),
		 ifc_div$mav_result[63:0]);
    if (RST_N != `BSV_RESET_VALUE)
      if (ifc_div$mav_result[64] && rg_cnt == 6'd7)
	$display("after cycle %d    the 32 bit unsigned divsion quotient = %h",
		 $signed(rg_cycle),
		 ifc_div$mav_result[63:0]);
    if (RST_N != `BSV_RESET_VALUE)
      if (ifc_div$mav_result[64] && rg_cnt == 6'd8)
	$display("after cycle %d    the 32 bit unsigned divsion remainder = %h \n",
		 $signed(rg_cycle),
		 ifc_div$mav_result[63:0]);
    if (RST_N != `BSV_RESET_VALUE)
      if ((rg_cycle[31] ?
	     -IF_rg_cycle_BIT_31_THEN_NEG_rg_cycle_ELSE_rg_c_ETC___d7 :
	     IF_rg_cycle_BIT_31_THEN_NEG_rg_cycle_ELSE_rg_c_ETC___d7) ==
	  32'd0 &&
	  rg_cnt == 6'd0)
	$display("divident = %h ,  divisor = %h",
		 64'h0000000000045FEA,
		 64'h0000000000023BC3);
    if (RST_N != `BSV_RESET_VALUE)
      if ((rg_cycle[31] ?
	     -IF_rg_cycle_BIT_31_THEN_NEG_rg_cycle_ELSE_rg_c_ETC___d7 :
	     IF_rg_cycle_BIT_31_THEN_NEG_rg_cycle_ELSE_rg_c_ETC___d7) ==
	  32'd0 &&
	  rg_cnt == 6'd2)
	$display("\n \n divident = %h ,  divisor = %h",
		 64'h0000000000045FEA,
		 64'h0000000000023BC3);
    if (RST_N != `BSV_RESET_VALUE)
      if ((rg_cycle[31] ?
	     -IF_rg_cycle_BIT_31_THEN_NEG_rg_cycle_ELSE_rg_c_ETC___d7 :
	     IF_rg_cycle_BIT_31_THEN_NEG_rg_cycle_ELSE_rg_c_ETC___d7) ==
	  32'd0 &&
	  rg_cnt == 6'd4)
	$display("\n\ndivident = %h ,  divisor = %h",
		 64'h0000000000045FEA,
		 64'h0000000000023BC3);
    if (RST_N != `BSV_RESET_VALUE)
      if ((rg_cycle[31] ?
	     -IF_rg_cycle_BIT_31_THEN_NEG_rg_cycle_ELSE_rg_c_ETC___d7 :
	     IF_rg_cycle_BIT_31_THEN_NEG_rg_cycle_ELSE_rg_c_ETC___d7) ==
	  32'd0 &&
	  rg_cnt == 6'd6)
	$display("\n\ndivident = %h ,  divisor = %h",
		 64'h0000000000045FEA,
		 64'h0000000000023BC3);
    if (RST_N != `BSV_RESET_VALUE) if (rg_cycle == 32'd400) $finish(32'd0);
  end
  // synopsys translate_on
endmodule  // mk_tb_srt_radix4_divider_64

